//
//TODO:
//  operators
// 
// StringHash is jsut a "struct StringHash { int value; }", so it might make sense
// to avoid binding it, and manually handle it instead.
//
// The API uses "StringHash&" as a return type extensively, it might be worth
// creating a StringHashRef struct perhaps that is a "struct StringHashRef { IntPtr value }" and
// that is implicitly convertible to a StringHash by dereferencing the value
//

using System;
using System.Collections.Generic;
using Clang.Ast;
using ICSharpCode.NRefactory.CSharp;
using System.Linq;
using Attribute = ICSharpCode.NRefactory.CSharp.Attribute;
using System.Reflection;
using Sharpie.Bind;


namespace SharpieBinder
{
	class CxxBinder : AstVisitor
	{
		public static Clang.Ast.Type CleanType (QualType qt)
		{
			var et = qt.Type as ElaboratedType;
			if (et == null)
				return qt.Type;
			return et.UnqualifiedDesugaredType;
		}

		class BaseNodeType
		{
			public CXXRecordDecl Decl { get; set; }

			readonly Action<CXXRecordDecl, CXXRecordDecl> bindHandler;

			public BaseNodeType(Action<CXXRecordDecl, CXXRecordDecl> bindHandler)
			{
				this.bindHandler = bindHandler;
			}

			public void Bind()
			{
				bindHandler(null, Decl);
			}

			public void Bind(CXXRecordDecl decl)
			{
				bindHandler(Decl, decl);
			}
		}

		readonly List<SyntaxTree> syntaxTrees = new List<SyntaxTree>();
		readonly Dictionary<string, BaseNodeType> baseNodeTypes;

		TypeDeclaration astVisitorType;
		TypeDeclaration currentType;

		public CxxBinder()
		{
			baseNodeTypes = new Dictionary<string, BaseNodeType>
			{
				["Urho3D::Object"] = new BaseNodeType(Bind),
				["Urho3D::StringHash"] = new BaseNodeType (Bind),
				//["clang::DeclContext"] = new BaseNodeType(Bind),
				//["clang::Decl"] = new BaseNodeType(Bind),
				//["clang::Type"] = new BaseNodeType(Bind),
				//["clang::Attr"] = new BaseNodeType(Bind),
				//["clang::Stmt"] = new BaseNodeType(Bind)
			};
		}

		public IEnumerable<SyntaxTree> Generate()
		{
			foreach (var syntaxTree in syntaxTrees)
			{
				syntaxTree.AcceptVisitor(new Sharpie.Bind.Massagers.GenerateUsingStatementsMassager());
				yield return syntaxTree;
			}
		}

		CXXRecordDecl GetRootDecl(CXXRecordDecl decl)
		{
			return baseNodeTypes.Values.FirstOrDefault(node =>
													   node.Decl != null &&
													   node.Decl.Name != "DeclContext" &&
													   decl.IsDerivedFrom(node.Decl))?.Decl;
		}

		void PushType(TypeDeclaration typeDeclaration)
		{
			var syntaxTree = new SyntaxTree
			{
				FileName = typeDeclaration.Name + ".cs"
			};

			var headerLines = String.Format(
				"WARNING - AUTOGENERATED - DO NOT EDIT\n\n" +
				"Generated using `sharpie urho`\n\n" +
				"{0}\n\n" +
				"Copyright 2015 Xamarin Inc. All rights reserved.", syntaxTree.FileName
			).Split('\n');
			headerLines[headerLines.Length - 1] += "\n";

			foreach (var line in headerLines)
				syntaxTree.Members.Add(new Comment(" " + line));

			syntaxTree.Members.Add(new UsingDeclaration("System"));

			var ns = new NamespaceDeclaration("Urho");
			syntaxTree.Members.Add(ns);
			syntaxTrees.Add(syntaxTree);

			ns.Members.Add(currentType = typeDeclaration);
		}

		public override void VisitEnumDecl(EnumDecl decl, VisitKind visitKind)
		{
			if (visitKind != VisitKind.Enter || !decl.IsCompleteDefinition || decl.QualifiedName == null)
				return;

			Console.WriteLine($"--here: {decl.QualifiedName}");
			string typeName;

			switch (decl.QualifiedName)
			{
				case "clang::Decl::Kind":
					typeName = "DeclKind";
					break;
				case "clang::Type::TypeClass":
					typeName = "TypeKind";
					break;
				case "clang::BuiltinType::Kind":
					typeName = "BuiltinTypeKind";
					break;
				case "clang::attr::Kind":
					typeName = "AttrKind";
					break;
				case "clang::Stmt::StmtClass":
					typeName = "StmtKind";
					break;
				default:
					return;
			}

			PushType(new TypeDeclaration
			{
				Name = typeName,
				ClassType = ClassType.Enum,
				Modifiers = Modifiers.Public
			});

			foreach (var constantDecl in decl.Decls<EnumConstantDecl>())
			{
				var valueName = constantDecl.Name;

				switch (valueName)
				{
					case "NUM_ATTRS":
					case "LAST_INHERITABLE_PARAM":
					case "LAST_INHERITABLE":
					case "LastKind":
					case "TypeLast":
					case "TagFirst":
					case "TagLast":
						continue;
				}

				if (valueName.StartsWith("first", StringComparison.Ordinal) ||
					valueName.StartsWith("last", StringComparison.Ordinal))
					continue;

				if (typeName == "StmtKind")
				{
					if (valueName.EndsWith("Class", StringComparison.Ordinal))
						valueName = valueName.Substring(0, valueName.Length - 5);

					if (valueName == "NoStmt")
						valueName = "None";
				}

				currentType.Members.Add(new EnumMemberDeclaration { Name = valueName });
			}
		}

		public override void VisitCXXRecordDecl(CXXRecordDecl decl, VisitKind visitKind)
		{
			if (visitKind != VisitKind.Enter || !decl.IsCompleteDefinition || decl.Name == null)
				return;

			BaseNodeType baseNodeType;
			if (baseNodeTypes.TryGetValue(decl.QualifiedName, out baseNodeType))
			{
				baseNodeType.Decl = decl;
				if (decl.QualifiedName != "clang::DeclContext")
					baseNodeType.Bind();
				return;
			}

			switch (decl.QualifiedName)
			{
				case "clang::ObjCObjectTypeImpl":
					// from the docs: "Code outside of ASTContext and the
					// core type system should not reference this type."
					return;
			}

			foreach (var bnt in baseNodeTypes.Values)
			{
				if (bnt.Decl != null && decl.IsDerivedFrom(bnt.Decl))
				{
					bnt.Bind(decl);
					return;
				}
			}
		}

		void Bind(CXXRecordDecl baseDecl, CXXRecordDecl decl)
		{
			var name = decl.Name;
			Console.WriteLine(name);
			PushType(new TypeDeclaration
			{
				Name = decl.Name,
				ClassType = ClassType.Class,
				Modifiers = Modifiers.Partial | Modifiers.Public
			});

			if (baseDecl != null)
			{
				foreach (var baseType in decl.Bases)
				{
					var baseName = baseType.Decl?.Name;
					if (baseName == null)
						continue;

					if (currentType.BaseTypes.Count > 0)
						baseName = "I" + baseName;

					currentType.BaseTypes.Add(new SimpleType(baseName));
				}
			}

			var nativeCtor = new ConstructorDeclaration
			{
				Modifiers = Modifiers.Internal,
				Body = new BlockStatement(),
				Initializer = new ConstructorInitializer()
			};

			nativeCtor.Parameters.Add(new ParameterDeclaration(new SimpleType("IntPtr"), "handle"));
			nativeCtor.Initializer.Arguments.Add(new IdentifierExpression("handle"));

			currentType.Members.Add(nativeCtor);


			//GenerateAcceptAstVisitor(decl);
		}

		public static AstType CreateAstType(string dottedName, IEnumerable<AstType> typeArguments)
		{
			var parts = dottedName.Split('.');
			if (parts.Length == 1)
				return new SimpleType(dottedName, typeArguments);

			AstType type = new SimpleType(parts[0]);

			for (int i = 1; i < parts.Length; i++)
			{
				if (i < parts.Length - 1)
					type = new MemberType(type, parts[i]);
				else
					type = new MemberType(type, parts[i], typeArguments);
			}

			return type;
		}

		AstType GenerateReflectedType(System.Type type)
		{
			if (type == typeof(void))
				return new PrimitiveType("void");

			var name = type.FullName;
			if (type.IsGenericType)
				name = name.Substring(0, name.IndexOf('`'));

			return CreateAstType(name, type.GetGenericArguments().Select(at => GenerateReflectedType(at)));
		}

		void GenerateDeclContext()
		{
			var declContextType = typeof(IDeclContext);
			var templateType = declContextType.Assembly.GetType("Clang.Ast.IDeclContextTemplate", false);
			if (templateType != null)
				declContextType = templateType;

			foreach (var member in declContextType.GetMembers())
			{
				var prop = member as PropertyInfo;
				if (prop != null)
				{
					var propertyDeclaration = new PropertyDeclaration
					{
						Name = prop.Name,
						Modifiers = Modifiers.Public,
						ReturnType = GenerateReflectedType(prop.PropertyType),
					};

					if (prop.CanRead)
						propertyDeclaration.Getter = new Accessor
						{
							Body = new BlockStatement {
								new ReturnStatement (
									new InvocationExpression (
										new MemberReferenceExpression (
											new IdentifierExpression ("DeclContextImpl"),
											prop.Name
										),
										new ThisReferenceExpression ()
									)
								)
							}
						};

					if (prop.CanWrite)
						throw new NotImplementedException("property setters for IDeclContext");

					currentType.Members.Add(propertyDeclaration);
				}

				var meth = member as MethodInfo;
				if (meth != null && !meth.IsSpecialName && meth.Name != "Accept")
				{
					var invocation = new InvocationExpression(
						new MemberReferenceExpression(
							new IdentifierExpression("DeclContextImpl"),
							meth.Name
						),
						new Expression[] { new ThisReferenceExpression() }.Concat(
							meth.GetParameters().Select(p => new IdentifierExpression(p.Name))
						)
					);

					var methodDeclaration = new MethodDeclaration
					{
						Name = meth.Name,
						Modifiers = Modifiers.Public,
						ReturnType = GenerateReflectedType(meth.ReturnType),
					};

					if (meth.ReturnType == typeof(void))
						methodDeclaration.Body = new BlockStatement { invocation };
					else
						methodDeclaration.Body = new BlockStatement {
							new ReturnStatement (invocation)
						};

					foreach (var param in meth.GetParameters())
						methodDeclaration.Parameters.Add(new ParameterDeclaration(
							GenerateReflectedType(param.ParameterType), param.Name));

					currentType.Members.Add(methodDeclaration);
				}
			}
		}

		static string MakeName (string typeName)
		{
			return typeName;
		}

		public override void VisitCXXMethodDecl (CXXMethodDecl decl, VisitKind visitKind)
		{
			if (currentType == null) {
				// Global definitions, not inside a class, skip
				return;
			}
			
			if (visitKind != VisitKind.Enter)
				return;

			if (decl is CXXConstructorDecl || decl is CXXDestructorDecl)
				return;


			if (decl.IsCopyAssignmentOperator || decl.IsMoveAssignmentOperator)
				return;

			// TODO: temporary, do not handle opreators
			if (decl.Name.StartsWith ("operator"))
				return;


			// PInvoke declaration
			var pinvoke = new MethodDeclaration {
				Name = "e_" + MakeName (currentType.Name) + "_" + decl.Name,
				ReturnType = CleanType (decl.ReturnQualType).Bind (),
				Modifiers = Modifiers.Extern | Modifiers.Static
			};
			if (!decl.IsStatic)
				pinvoke.Parameters.Add (new ParameterDeclaration (new SimpleType ("IntPtr"), "handle"));

			var dllImport = new Attribute () {
				Type = new SimpleType ("DllImport")
			};
			dllImport.Arguments.Add (new PrimitiveExpression ("mono-urho"));

			pinvoke.Attributes.Add (new AttributeSection (dllImport));
			currentType.Members.Add (pinvoke);

			// Method declaration
			var method = new MethodDeclaration {
				Name = decl.Name,
				ReturnType = CleanType (decl.ReturnQualType).Bind (),
				Modifiers = (decl.IsStatic ? Modifiers.Static : 0)
			};

			foreach (var param in decl.Parameters)
				method.Parameters.Add (new ParameterDeclaration (CleanType (param.QualType).Bind (), param.Name));
			method.Body = new BlockStatement () {
				
			};
				
			currentType.Members.Add (method);
		}

	}
}